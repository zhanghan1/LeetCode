package easy;

/*预备知识：
 * 位运算
 * a.移位运算
 *   >> 右移, << 左移， >>>无符号左移
 * b.位逻辑运算
 *   & 与, | 或, ~ 非(取反), ^ 异或
 *   
 * (1)朴素解法，即使用位运算
 * 
 * 如果函数需要被调用很多次，怎样优化？
 * (2)优化
 * 思路：以4字节为单位进行反转，将0x0至0xF的反转结果预存在长度为16的数组中，
 *      反转时直接查询即可
 * (0000)-(0000) 即0->0
 * (0001)-(1000) 即1->8
 * (0010)-(0100) 即2->4
 * (0011)-(1100) 即3->12
 * (0100)-(0010) 即4->2
 * (0101)-(1010) 即5->10
 * (0110)-(0110) 即6->6
 * (0111)-(1110) 即7->14
 * (1000)-(0001) 即8->1
 * (1001)-(1001) 即9->9
 * (1010)-(0101) 即10->5
 * (1011)-(1101) 即11->13
 * (1100)-(0011) 即12->3
 * (1101)-(1011) 即13->11
 * (1110)-(0111) 即14->7
 * (1111)-(1111) 即15->15
 */
public class P190_ReverseBits {

	// //解法1：朴素解法
	// public static int reverseBits(int n) {
	// int result = 0;
	// for (int i = 0; i < 32; i++) {
	// result <<= 1;
	// result += (n & 1);
	// n >>= 1;//leetCode上有人说，要使用 n >>>= 1(无符号转移)，但是现在也是正确的
	// }
	// return result;
	// }

	// 解法2：
	static char tb[] = new char[] { 0, 8, 4, 12, 2, 10, 6, 14, 1, 9, 5, 13, 3, 11, 7, 15 };
	public static int reverseBits(int n) {
		int result = 0;
		
		for (int i = 0; i < 8; i++) {
			result <<= 4;
			int temp = n & 0xF;
			result += (int)tb[temp];
			n >>= 4;
		}
		return result;
	}

	public static void main(String args[]) {
		int n = 43261596;
		System.out.println(reverseBits(n));
	}
}
